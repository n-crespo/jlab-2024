# Results

Though the required functionality could have been established in various different ways, by encapsulating core functionality within custom components with specialized functions, the code can be reusable, much easier to debug and more readable.

Almost all queries used rely on the careful matching of primary and foreign keys across tables. Primary keys are keys that are unique to a table, while foreign keys are values that must be matched with their corresponding values in another table to be used. For example, every traveler is given a unique `TRAVELER_ID` which is a primary key in the `INV_TRANSACTIONS` table. This means each record in `INV_TRANSACTIONS` has a unique `TRAVELER_ID`. However, each record also has a field called `LOCATIONID`, which is a foreign key. Inside of the `INV_TRANSACTIONS` table the `LOCATIONID` is just a number, but a separate table, in this case `INV_LOCATIONS`, can be queried using that `LOCATIONID` to retrieve the correct location. The `LOCATIONID` is a primary key in the `INV_LOCATIONS` table, where each record has a unique `LOCATIONID` and a specified name, description, and more.

Two initial queries to the `TRAV_ACRONYMS` table in the Travelers database return details about all possible work centers and actions in a dash-separated format. By specifying certain fields like `obs`, for obsolete, `CLOSED`, and `RETIRED` as `null`, any work centers or actions that are no longer in user or are invalid are not included in the query. A third query to the `INV_LOCATIONS` table in the `PRIMeS` database collects all valid location IDs. These three queries are fed into `<cfselect>` tags inside of a form as to populate three drop downs with their results. A `NULL` action was also hard coded into the Location ID drop-down box due to certain travelers omitting that field. Finally, the `action=` field of the form specifies a separate ColdFusion script that sets the cookies named `wca`, `action` and `loc_id` to their selected values by invoking a method in a custom `CookieBuilder` component.

On the Transaction ID entry page, almost all functionality is dependent on a conditional statement that requires all cookies to be defined properly and the entry box to have been submitted with a valid integer value. The text entry stores any submitted value to the variable `tid` which first used in a large `getTravID` function from the custom `TravIDBuilder` component. The `getTravID` function immediately calls the `getTravData` function, which includes a query that returns important data about the transaction ID. The `TID` is sent to this function through the `tid` parameter, then introduced into the query using a `<cfqueryparam>` tag. This tag allows the programmer to specify what kind of data a value _should_ be to avoid SQL injection attacks. By ensuring the `tid` that is inserted is a valid integer, a user with malicious intent cannot inject SQL code into the query and potentially compromise the database. The results from the call to `getTravData` are returned as a query, then used alongside preset cookie values in a series of string concatenations that build a valid Traveler ID.

Next, the `shouldUpdateLogs` method in the `TravIDBuilder` component is used to query the `INV_TRANSACTIONS` and `INV_INVENTORY` tables to determine if the part is still in inventory. The `INV_TRANSACTIONS` table houses a history of all traveler, while the `INV_INVENTORY` table houses a list of all parts in inventory. If the part is in the inventory and is not already in the current user's location, a new record is inserted into the `INV_TRANSACTIONS` table and the corresponding record in the`INV_INVENTORY` table is be updated with the new location ID.

It is possible for a traveler to have multiple revisions added to it as certain actions are performed on it multiple times. A call to the `getRevisionNumber` method of the `TravIDBuilder` component returns the total number of revisions a traveler has received and, if valid, it is appended to the Traveler ID. The final piece of information needed for building the URL and redirecting the user is the maximum page number of the traveler, which is found bu querying the `TRAV_HEADAER` table in the `PRIMeS` database. Finally, all information found including the project name, work center, traveler ID, revision number and max page is concatenated to a URL the user is redirected to.

In the case of the `getRevisionNumber` function returning an empty string, meaning the Traveler ID is invalid, the `getTravIDExtended` function is called. By attempting to match the traveler ID with a filtered set of options with the `LIKE` keyword in SQL and a nested query, this function returns a list of possible traveler IDs that the user can search through and select. As the user types in the provided text input box, the results are filtered with JavaScript to contain only those that match the user's input. When a valid option is selected, the `submitTravID.cfm` script is executed, which redirects the user to the correct traveler page with the now adequate amount of information.
