# Results

Though the required functionality could have been established in various different ways, by encapsulating core functionality within custom components with specialized functions, the code can be reusable, much easier to debug and more readable.

Almost all queries used rely on the careful matching of primary and foreign keys
across tables. Primary keys are keys that are unique to a table, while foreign
keys are values that must be matched with their corresponding values in another table to be used. For example, every traveler is given a unique `TRAVELER_ID` which is a primary key in the `INV_TRANSACTIONS` table. This means each record in `INV_TRANSACTIONS` has a unique `TRAVELER_ID`. However, each record also has a field called `LOCATIONID`, which is a foreign key. Inside of the `INV_TRANSACTIONS` table the `LOCATIONID` is just a number, but a separate table, in this case `INV_LOCATIONS`, can be queried using that `LOCATIONID` to retrieve the correct location. The `LOCATIONID` is a primary key in the `INV_LOCATIONS` table, where each record has a unique `LOCATIONID` and a specified name, description, and more.

Two initial queries to the `TRAV_ACRONYMS` table in the Travelers database return details about all possible work centers and actions in a dash-separated format. By specifying certain fields like `obs`, for obsolete, `CLOSED`, and `RETIRED` as `null`, any work centers or actions that are no longer in user or are invalid are not included in the query. A third query to the `INV_LOCATIONS` table in the `PRIMeS` database collects all valid location IDs. These three queries are fed into `<cfselect>` tags inside of a form as to populate three drop downs with their results. A `NULL` action was also hard coded into the Location ID drop-down box due to certain travelers omitting that field. Finally, the `action=` field of the form specifies a separate ColdFusion script that sets the cookies named `wca`, `action` and `loc_id` to their selected values by invoking a method in a custom `CookieBuilder` component.

On the Transaction ID entry page, almost all functionality is dependent on a conditional statement that requires all cookies to be defined properly and the entry box to have been submitted. The text entry stores any submitted value to the variable `tid` which first used in a large `getTravID` function from the custom `TravIDBuilder` component. The `getTravID` function immediately calls the `getTravData` function, which includes a query that returns important data about the transaction ID. The `TID` is sent to this function through the `tid` parameter, then introduced into the query using a `<cfqueryparam>` tag. This tag allows the programmer to specify what kind of data a value _should_ be to avoid SQL injection attacks. By ensuring the `tid` that is inserted is a valid integer, a user with malicious intent cannot inject SQL code into the query and potentially compromise the database. The results from the call to `getTravData` are returned as a query, then used alongside preset cookie values in a series of string concatenations that build a valid Traveler ID.

It is possible for a traveler to have multiple revisions added to it as certain
actions are performed on it multiple times. A call to the `getRevisionNumer`
method o the `TravIDBuilder` component returns the total number of revisions a
traveler has received, which is then concatenated to the end of the traveler ID.
